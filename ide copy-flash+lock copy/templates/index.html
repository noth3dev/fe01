<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/material-darker.min.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/material-darker.min.css">

    <link rel="stylesheet" href="../static/styles.css">
    <link rel="icon" type="image/x-icon" href="../static/asset/FAVICON.svg">
    <audio id="flashbangSound" src="../static/asset/flashbang.mp3" preload="auto"></audio>

    <style>
            #countdown{
                font-size: 50px;
                font-weight: 900;
                font-family: pretendard;
                color: gray;
            }   
            .semititle{
                font-size: 20px;
                font-family: pretendard;
            }

        </style>
</head>
<body>

    <div id="escoverlay" class="escoverlay">
        <div class="escoverlay-content">
          <h2 id="menu-title">SHAKECODE</h2>
          <hr>
          <!-- Initial Button Container -->
          <div id="button-container" class="button-container">
            <button id="continue-btn" class="menu-button">Continue</button>
            <button id="settings-btn" class="menu-button">Settings</button>
            
            <div class="gap"></div>
            <button id="exit-game-btn" class="menu-button">Exit Game</button>
            <button id="exit-lobby-btn" class="menu-button">Exit to Lobby</button>
          </div>
      
          <!-- Surrender Prompt -->
          <div id="surrender-container" class="surrender-container">
            <p id="surrender-text">Would you surrender?</p>
            <div class="subtext">you will lose more points and get penalty</div>
            <div class="surrender-buttons">
              <button id="confirm-surrender-btn" class="menu-button">Yes</button>
              <button id="cancel-surrender-btn" class="menu-button">No</button>
            </div>
          </div>
        </div>
      </div>
      
      

    <div id="stunoverlay">
        <div id="countdown-timer" style="font-size: 2rem; color: white;">Stun ends in: 5s</div>
    </div>

    <div id="roundendScreen" class="roundend-transition">
        <div class="subtext">SHAKE UP THE CODE.</div>

        <div id="resultText" class="win"></div>
    </div>
    <div id="math-problem-modal">
        <div id="math-problem-question"></div>
        <input type="text" id="math-problem-answer" placeholder="Enter answer">
        <button class="decaybutton" onclick="submitMathProblem()">Submit</button>
        <div id="timer-display" style="margin-top:10px; color:red;">Time left: 10s</div> <!-- 타이머 표시 -->
    </div>
    
    
    <div class="container">
        <div class="blur-background"></div> <!-- 블러 배경 -->
        <div class="problem-section">
            <button id="toggle-fullscreen">전체 화면 전환</button>


            <div id="debuff-container" style="position: fixed; top: 10px; left: 10px; z-index: 1000;">

            </div>

            <div class="problemtitle">
                <img src="../static/asset/logo_casual.svg" width="16px">
                <span id="problem-title">이러저러한 이름</span>
            </div>
            <div class="problemtitlesource">
                <span id="problem-source">이러저러한 출처</span>
            </div>
            <hr>
            <div class="problemintitle">문제<br>
                <span id="problem-description">이러저러하고 이러저러한 문제이다</span>
            </div>
            <div class="problemintitle">입력<br>
                <span id="problem-input-format">이러저러한 입력이 이러저러한 형식으로 들어온다</span>
            </div>
            <div class="problemintitle">출력<br>
                <span id="problem-output-format">이러저러한 출력이 이러저러한 형식으로 나간다</span>
            </div>
            <div class="problemintitle">테스트케이스<br>
                <span id="test-cases">
                    <div class="problemintitle" style="font-size: 14px;">테스트케이스 1:<br></div>
                    <div class="testcase-container">
                        <div class="testcase-display">
                            <div class="testcase-title">예제 입력</div>
                            <div class="testcase-content input-content">이러저러한 입력</div>
                        </div>
                        <div class="testcase-display">
                            <div class="testcase-title">예제 출력</div>
                            <div class="testcase-content output-content">깔@쌈한 출력</div>
                        </div>
                    </div>
                </span>
            </div>
            <div class="problemintitle">추가 조건<br>
                <span id="problem-additional-info">
                    이 문제에는 이러저러한 것에 대한 이러저러한 추가 조건이 있다.<br>
                    메모리 조건은 이러저러하고, 시간 조건은 이러저러하다.
                </span>
            </div>
            <hr style="margin-top: 30px;">
            <div class="problemintitle">정보<br>
                <span>  
                    <span class="difficulty" id="problem-difficulty">난이도 : ~~</span><br>
                    <span class="source" id="problem-source-detail">출처: ~~</span>
                </span>
            </div>
        </div>

        <div class="editor-section">

            <div class="editor-area">
                <div class="txt-head">
                    <div class="rival">
                        <span>VS</span>
                        <span id="opponent-player">Opponent player</span>
                    </div>
                    <div class="right-icons">
                        <div id="character-count-container">
                            <div id="my-character-count">0</div>
                            vs
                            <div id="opponent-character-count">0</div>
                        </div>
                        <button>Selected : </button>
                        <select class="dropdown" id="language-selector">
                            <option value="text/x-csrc">C</option>
                            <option value="text/x-python">Python</option>
                            <option value="text/x-c++src">C++</option>
                            <option value="text/x-java">Java</option>
                        </select>
                        <button onclick="runCode()">Test</button>
                        <button id="submit-all" onclick="handleSubmit()">Submit</button>
                    </div>
                </div>
                <textarea id="code-editor" maxlength ="5000"></textarea>

            <div class="console-head">
                <div class="console-head-inner">
                    <div style="display: flex;">
                        <img src="../static/asset/Xpingame.svg" width="20px">
                        <div class="xp">170</div>
                        <div class="xpadd">token added at win</div>
                    </div>
                    <div class="round-container">
                        <span class="status win">W</span>
                        <span class="status lose">L</span>
                        <span class="status win">W</span>
                        <span class="status lose">L</span>
                        <span class="status miss">M</span>
                    </div>
                </div>
            </div>
            <div class="console-area">
                <div class="consolemenu-menu">
                    <span class="consolemenu-item active">MY OUTPUT</span>
                    <span class="consolemenu-item log">MY INPUT</span>
                    <span class="consolemenu-item submitted-log">SUBMITTED LOG</span>   
                    <span class="consolemenu-item log">SKILLS</span>
                </div>
                <div class="consolemenu-content">
                    <div class="active" id="my-output">console....</div>

                    <div id="my-input">
                        <textarea id="input-field" placeholder="Enter input here..."></textarea>
                    </div>
                    <div id="results-container">

                    </div>
                    <div id="skills">
                        <div class="status-dots" id="total-status-dot">
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                            <div class="status-dot"></div>
                        </div>

                        <div class="skill-bar" id="warden-skill-bar">
                            <div class="skill-item">
                                <div class="skill-icon" onclick="useSkill('disable_submit')" id="lockdown-icon">
                                    <img src="../static/asset/lock.svg">
                                </div>
                                <div class="status-dots" id="lockdown-status-dot">
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                </div>
                                <div class="skill-text">Lockdown</div>
                                <div class="skill-subtext">Lock down opponent's runcode/skills</div>
                                <div id="disable_submit_timer" class="skill-timer"></div> <!-- 남은 시간 표시 -->
                            </div>

                            <!-- 두 번째 스킬 -->
                            <div class="skill-item">
                                <div class="skill-icon" onclick="useSkill('disable_typing')" id="flashbang-icon">
                                    <img src="../static/asset/flashbang.svg">
                                </div>
                                <div class="status-dots" id="flashbang-status-dot">
                                    <div class="status-dot"></div>
                                </div>
                                <div class="skill-text">Flashbang</div>
                                <div class="skill-subtext">Flash enemy and stun for short time</div>
                                <div id="disable_typing_timer" class="skill-timer"></div> <!-- 남은 시간 표시 -->
                            </div>

                        </div>
                        <div class="skill-bar" id="viper-skill-bar">
                            
                            <div class="skill-item">
                                <div class="skill-icon" onclick="useSkill('decay')" id="decay-icon">
                                    <img src="../static/asset/viper.svg">
                                </div>
                                <div class="status-dots" id="decay-status-dot">
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                </div>
                                <div class="skill-text">Decay</div>
                                <div class="skill-subtext">Gradually erodes code til they solve the problem</div>
                                <div id="decay_timer" class="skill-timer" style="visibility: hidden;"></div> 
                            </div>    
                            <div class="skill-item">
                                <div class="skill-icon" id="toxic_cloud-icon" onclick="useSkill('toxic_cloud')">
                                    <img src="../static/asset/toxic_cloud.svg">
                                </div>
                                <div class="status-dots" id="toxic_cloud-status-dot">
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                    <div class="status-dot"></div>
                                </div>
                                <div class="skill-text">Toxic cloud</div>
                                <div class="skill-subtext">Smoke and blind enemy's screen</div>
                                <div id="toxic_cloud_timer" class="skill-timer"></div> <!-- 남은 시간 표시 -->
                            </div>
                            
                        </div>
                 </div>
                </div>
            </div>
        </div>
    </div>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/material-darker.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/hint/show-hint.min.css">
    <script>let istoxic_cloudActive = false;  // toxic_cloud 스킬의 활성화 상태를 추적하는 변수</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.6/addon/edit/closebrackets.min.js"></script>
    <script src="../static/script.js"></script>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
    
document.getElementById('exit-lobby-btn').addEventListener('click', function () {
  const buttonContainer = document.getElementById('button-container');
  const surrenderContainer = document.getElementById('surrender-container');
  
  // Hide the initial button container
  buttonContainer.style.opacity = '0';
  buttonContainer.style.transform = 'translateY(-100%)';
  
  // Show the surrender prompt after the transition
  setTimeout(() => {
    buttonContainer.style.display = 'none'; // Hide the original buttons
    surrenderContainer.style.display = 'flex';
    surrenderContainer.classList.add('show'); // Slide in the surrender text
  }, 500); // Match the transition duration
});

// Event listener for 'No' button (cancel surrender)
document.getElementById('cancel-surrender-btn').addEventListener('click', function () {
  const buttonContainer = document.getElementById('button-container');
  const surrenderContainer = document.getElementById('surrender-container');
  
  // Hide the surrender prompt
  surrenderContainer.classList.remove('show');
  
  // Show the original buttons again
  setTimeout(() => {
    surrenderContainer.style.display = 'none';
    buttonContainer.style.display = 'flex';
    buttonContainer.style.opacity = '1';
    buttonContainer.style.transform = 'translateY(0)';
  }, 500); // Match the transition duration
});
document.getElementById('continue-btn').addEventListener('click', function () {
  const escoverlay = document.getElementById('escoverlay');
  escoverlay.classList.remove('show'); // Hide the overlay
});


document.getElementById('toggle-fullscreen').addEventListener('click', function() {
    var problemSection = document.querySelector('.problem-section');
    var blurBackground = document.querySelector('.blur-background');
    problemSection.classList.toggle('fullscreen-mode');
    blurBackground.classList.toggle('active'); // 클래스를 토글
});

document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        toggleEscOverlay();
    }
});
function toggleEscOverlay() {
    const escoverlay = document.getElementById('escoverlay');
    if (escoverlay.classList.contains('show')) {
        escoverlay.classList.remove('show'); // Hide the overlay
        escoverlay.style.display = 'none';
    } else {
        escoverlay.classList.add('show'); // Show the overlay
        escoverlay.style.display = 'flex';
    }
}



let selectedClass = 'viper';

let currentSkillPoints = 0;

const submitlockdowntime = 20;
const decaytime = 10;
const toxic_cloudtime = 20;
let countdownDuration = 8000; 
let isSkillLocked = false; 


let isDeleting = false; 
let countdownStartTime; 

let countdownInterval;
let decayInterval;
let currentMathProblem;
let codeDeletionInterval;



const skillCost = {
    'disable_submit': 5,
    'disable_typing': 1,
    /////
    'decay': 7,
    'toxic_cloud': 3
};

function updateSkillBar() {
    const wardenSkillBar = document.getElementById('warden-skill-bar');
    const viperSkillBar = document.getElementById('viper-skill-bar');

    if (selectedClass === 'warden') {
        wardenSkillBar.style.display = 'flex';
        viperSkillBar.style.display = 'none';
    } else if (selectedClass === 'viper') { 
        wardenSkillBar.style.display = 'none';
        viperSkillBar.style.display = 'flex';
    }
}

function selectClass(newClass) {
    selectedClass = newClass;
    updateSkillBar();
}

document.addEventListener('DOMContentLoaded', function() {
    updateSkillBar();
});


var socket = io.connect('http://127.0.0.1:5000');

var client_id = prompt("Please enter your ID:");

if (client_id) {
    socket.emit('register', {
        client_id: client_id
    });
    alert("You have entered ID: " + client_id);
}

socket.on('opponent_found', function(data) {
    document.getElementById('opponent-player').innerHTML = data.opponent_id;
});
function updateFontSizeBasedOnCount(myCount, opponentCount) {
    const myCharacterElement = document.getElementById('my-character-count');
    const opponentCharacterElement = document.getElementById('opponent-character-count');

    // 기본 스타일 초기화
    myCharacterElement.style.fontSize = '16px';
    myCharacterElement.style.fontWeight = 'normal';
    opponentCharacterElement.style.fontSize = '16px';
    opponentCharacterElement.style.fontWeight = 'normal';

    // 더 큰 쪽에 큰 폰트 및 굵은 글씨 적용
    if (myCount > opponentCount) {
        myCharacterElement.style.fontSize = '18px';
        myCharacterElement.style.fontWeight = 'bold';
    } else if (opponentCount > myCount) {
        opponentCharacterElement.style.fontSize = '18px';
        opponentCharacterElement.style.fontWeight = 'bold';
    }
}

// 주석과 공백을 제외한 유효한 글자 수 계산 함수
function countValidCharacters(code) {
    // 주석 제거
    code = code.replace(/\/\*[\s\S]*?\*\//g, ''); // C, C++, Java 등 다중 주석 제거
    code = code.replace(/\/\/.*/g, ''); // 한 줄 주석 제거
    code = code.replace(/#.*$/gm, ''); // Python 주석 제거

    // 공백과 엔터 제거
    code = code.replace(/\s/g, '');

    return code.length; // 남은 문자의 길이 반환
}

// 0.3초마다 내 유효한 문자 수를 계산하고 상대방에게 전송
let myCharacterCount = 0;
let opponentCharacterCount = 0;
// 기존 에디터 설정 후 추가
// 글자 수 업데이트 함수 수정
editor.on('change', function () {
    const code = editor.getValue();  // 에디터에서 코드를 가져옴
    myCharacterCount = countValidCharacters(code);

    // 내 유효 문자 수를 화면에 업데이트
    const myCharacterElement = document.getElementById('my-character-count');
    myCharacterElement.innerText = `${myCharacterCount}`;

    // 애니메이션 클래스 추가
    myCharacterElement.classList.add('animate-count');

    // 애니메이션 후 클래스 제거
    setTimeout(() => {
        myCharacterElement.classList.remove('animate-count');
    }, 300);  // 애니메이션 길이와 일치하는 타이머 설정

    console.log(`Sending my valid character count: ${myCharacterCount}`);

    // 서버로 내 유효 문자 수 전송
    socket.emit('character_count', {
        sender_id: client_id,
        character_count: myCharacterCount
    });

    // 내 글자수와 상대방 글자수 비교 후 폰트 업데이트
    updateFontSizeBasedOnCount(myCharacterCount, opponentCharacterCount);
});


// 상대방의 유효 문자 수 수신 및 화면에 표시
// 상대방의 유효 문자 수 수신 및 화면에 표시
socket.on('opponent_character_count', function(data) {
    opponentCharacterCount = data.character_count;

    // 상대방의 유효 문자 수를 화면에 업데이트
    const opponentCharacterElement = document.getElementById('opponent-character-count');
    opponentCharacterElement.innerText = `${opponentCharacterCount}`;

    // 애니메이션 클래스 추가
    opponentCharacterElement.classList.add('animate-count');

    // 애니메이션 후 클래스 제거
    setTimeout(() => {
        opponentCharacterElement.classList.remove('animate-count');
    }, 300);  // 애니메이션 길이와 일치하는 타이머 설정

    // 내 글자수와 상대방 글자수 비교 후 폰트 업데이트
    updateFontSizeBasedOnCount(myCharacterCount, opponentCharacterCount);
});




socket.on('test_result_notification', function(data) {
    console.log('Notification received: ', data.message);

    if (data.message === "You Won!") {
        showRoundEndEffect(true);
    } else if (data.message === "You Lose!") {
        showRoundEndEffect(false);
    }
});

function showRoundEndEffect(isWin) {
    const roundEndScreen = document.getElementById('roundendScreen');
    const resultText = document.getElementById('resultText');
    const text = isWin ? "ROUND SECURED" : "ROUND LOST";

    resultText.classList.remove('win', 'lose', 'active', 'exit');

    resultText.classList.add(isWin ? 'win' : 'lose');

    resultText.innerHTML = '';
    text.split('').forEach((char, index) => {
        const span = document.createElement('span');
        if (char === ' ') {
            span.classList.add('space');
        } else {
            span.textContent = char;
            span.classList.add('letter');
            span.style.animationDelay = `${index * 0.1}s`;
        }
        resultText.appendChild(span);
    });

    const countdownElement = document.createElement('div');
    countdownElement.id = 'countdown';
    countdownElement.style.fontSize = '2rem';
    countdownElement.style.color = '#fff';
    countdownElement.style.marginTop = '20px';
    resultText.appendChild(countdownElement);

    roundEndScreen.style.display = 'flex';
    roundEndScreen.classList.add('active');
    roundEndScreen.style.zIndex = '100';

    let countdown = 4;
    const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown < 0) {
            clearInterval(countdownInterval);
            hideRoundEndEffect();
        }
    }, 1000);
}
function hideRoundEndEffect() {
    const roundEndScreen = document.getElementById('roundendScreen');
    const resultText = document.getElementById('resultText');
    const countdownElement = document.getElementById('countdown');

    // Add new screen for countdown
    const newScreen = document.createElement('div');
    newScreen.classList.add('new-screen');
    newScreen.innerHTML = `
        <div class='new-content'>
            <p class="semititle">Next round starts in</p>
            <p><span id="countdown">50</span> seconds</p>
        </div>`;
    document.body.appendChild(newScreen);

    let countdown = 50;
    const countdownTimer = setInterval(() => {
        if (countdown > 0) {
            countdown--;
            document.getElementById('countdown').textContent = countdown;
        } else {
            clearInterval(countdownTimer);
        }
    }, 1000);

    if (countdownElement) {
        countdownElement.remove();
    }

    // Slide down the new screen, then reset after the countdown ends
    newScreen.classList.add('slide-down');

    setTimeout(() => {
        newScreen.classList.add('slide-down');
        setTimeout(() => {
            newScreen.remove(); // Remove new screen after sliding down

            // Reset the editor, logs, and other elements
            resetForNextRound();

            roundEndScreen.style.zIndex = '-1';
            roundEndScreen.style.display = 'none';
        }, 2000); // Extra delay for sliding effect

    }, 50000); // 50 seconds delay before removing the new screen
}
function resetForNextRound() {
    // Reset CodeMirror editor content
    if (window.editor) {
        editor.setValue(''); // This clears the editor content
        editor.clearHistory(); // This clears the undo history
    }

    // Clear submission logs
    const resultsContainer = document.getElementById('results-container');
    while (resultsContainer.firstChild) {
        resultsContainer.removeChild(resultsContainer.firstChild);
    }

    // Reset skill points or any counters
    currentSkillPoints = 0;
    updateSkillPointsUI();

    // Remove any active debuff or temporary UI components
    const debuffContainer = document.getElementById('debuff-container');
    while (debuffContainer.firstChild) {
        debuffContainer.removeChild(debuffContainer.firstChild);
    }

    // Reset round status indicators
    const roundStatusElements = document.querySelectorAll('.status');
    roundStatusElements.forEach((status) => {
        status.classList.remove('win', 'lose', 'miss');
    });

    // ** Reset submitted-log color to default **
    const submittedLogTab = document.querySelector('.submitted-log');
    if (submittedLogTab) {
        submittedLogTab.style.color = ''; // Reset the color back to the default
    }

    // Reset any glow or other visual effects applied to the body
    resetTemporaryEffects();

    // Ensure animations restart correctly
    restartAnimations();
}

// Example function to reset temporary effects or visual overlays
function resetTemporaryEffects() {
    // Remove any overlays, blur effects, or other temporary elements
    const toxic_cloudOverlay = document.querySelector('.toxic_cloud-blur');
    if (toxic_cloudOverlay) {
        toxic_cloudOverlay.remove();
    }

    // Reset any glow or other visual effects applied to the body
    document.body.style.filter = 'none';
    document.body.classList.remove('glowing-inset-border');
}

// Ensure animations restart correctly
function restartAnimations() {
    const roundEndScreen = document.getElementById('roundendScreen');
    roundEndScreen.style.animation = 'none'; // Reset animation
    void roundEndScreen.offsetWidth; // Force reflow
    roundEndScreen.style.animation = ''; // Restart animation
}




document.getElementById("submit-all").addEventListener("click", function() {
    const code = editor.getValue();
    const language = document.getElementById("language-selector").value;

    console.log('Submitting code:', code, 'in', language);

    socket.emit('submit_code', {
        sender_id: client_id,
        code: code,
        language: language
    });
});


const funMessages = [
    "Oops! Looks like someone bit the dust!",
    "Oh no! The code gods are not pleased.",
    "Mission failed, we’ll get them next time!",
    "Error 404: Correct answer not found!",
    "Almost there... but not quite!",
    "The opponent's code exploded! Kaboom!",
    "Well, that didn’t go as planned, did it?",
    "Close, but no cigar for your opponent.",
    "Opponent has fallen in battle! Try again!"
];

function getRandomMessage() {
    return funMessages[Math.floor(Math.random() * funMessages.length)];
}

socket.on('submission_log', function(data) {

    if (data.sender !== client_id) {
        const resultsContainer = document.getElementById('results-container');

        const randomMessage = getRandomMessage();

        const submissionEntry = document.createElement('div');
        submissionEntry.className = 'submission-entry';
        submissionEntry.innerHTML = `
            <div class="testcase-box" style="background-color:#ECB666;">${randomMessage}</div>
        `;

        resultsContainer.appendChild(submissionEntry);

        const submittedLogTab = document.querySelector('.submitted-log');
        submittedLogTab.style.color = "red";

        submittedLogTab.addEventListener('click', function() {
            if (submittedLogTab.style.color === "red") {
                submittedLogTab.style.color = "";
            }
        });
    }
});

function updateSkillPointsUI() {
    const totalStatusDots = document.querySelectorAll('#total-status-dot .status-dot');

    totalStatusDots.forEach((dot, index) => {
        if (index < currentSkillPoints) {
            dot.style.backgroundColor = 'white';
        } else {
            dot.style.backgroundColor = 'gray';
        }
    });

    const flashbangSkillIcon = document.getElementById('flashbang-icon');
    const flashbangStatusDot = document.querySelector('#flashbang-status-dot .status-dot');

    if (currentSkillPoints >= skillCost['disable_typing']) {
        flashbangSkillIcon.classList.remove('disabled');
        flashbangStatusDot.style.backgroundColor = 'white';
    } else {
        flashbangSkillIcon.classList.add('disabled');
        flashbangStatusDot.style.backgroundColor = 'gray';
    }

    const lockdownSkillIcon = document.getElementById('lockdown-icon');
    const lockdownStatusDots = document.querySelectorAll('#lockdown-status-dot .status-dot');

    lockdownStatusDots.forEach((dot, index) => {
        if (index < currentSkillPoints) {
            dot.style.backgroundColor = 'white';
        } else {
            dot.style.backgroundColor = 'gray';
        }
    });

    if (currentSkillPoints >= skillCost['disable_submit']) {
        lockdownSkillIcon.classList.remove('disabled');
    } else {
        lockdownSkillIcon.classList.add('disabled');
    }


    const decaySkillIcon = document.getElementById('decay-icon');
    const decayStatusDots = document.querySelectorAll('#decay-status-dot .status-dot');

    decayStatusDots.forEach((dot, index) => {
        if (index < currentSkillPoints) {
            dot.style.backgroundColor = 'white';
        } else {
            dot.style.backgroundColor = 'gray';
        }
    });

    if (currentSkillPoints >= skillCost['decay']) {
        decaySkillIcon.classList.remove('disabled');
    } else {
        decaySkillIcon.classList.add('disabled');
    }

    const toxic_cloudSkillIcon = document.getElementById('toxic_cloud-icon');
    const toxic_cloudStatusDots = document.querySelectorAll('#toxic_cloud-status-dot .status-dot');

    toxic_cloudStatusDots.forEach((dot, index) => {
        if (index < currentSkillPoints) {
            dot.style.backgroundColor = 'white';
        } else {
            dot.style.backgroundColor = 'gray';
        }
    });

    if (currentSkillPoints >= skillCost['toxic_cloud']) {
        toxic_cloudSkillIcon.classList.remove('disabled');
    } else {
        toxic_cloudSkillIcon.classList.add('disabled');
    }

    console.log(`Current skill points: ${currentSkillPoints}`);
}

updateSkillPointsUI();

function useSkill(skillType) {
    if (isSkillLocked) {
        console.log("Skills are currently locked due to 'disable_submit'.");
        return; // Prevent using any skill while locked
    }

    const skillIcon = document.querySelector(`.skill-icon[onclick="useSkill('${skillType}')"]`);

    if (skillIcon.classList.contains('disabled')) {
        return; // Skill is already disabled
    }

    const cost = skillCost[skillType];
    if (currentSkillPoints < cost) {
        return; // Not enough skill points
    }

    currentSkillPoints -= cost;
    updateSkillPointsUI();

    socket.emit('use_skill', {
        sender_id: client_id,
        skill_type: skillType
    });

    skillIcon.classList.add('disabled');

    let duration;
    if (skillType === 'disable_submit') {
        duration = submitlockdowntime;
        isSkillLocked = true; // Lock all skills when 'disable_submit' is active
    } else if (skillType === 'disable_typing') {
        duration = 10;
    } else if (skillType === 'decay') {
        duration = 10;
    } else if (skillType === 'toxic_cloud') {
        duration = toxic_cloudtime;
    }

    startSkillTimer(skillType, duration, skillIcon);
}

function startSkillTimer(skillType, duration, skillIcon) {
    const timerElement = document.getElementById(`${skillType}_timer`);
    let remainingTime = duration;

    const updateTimer = () => {
        if (remainingTime > 0) {
            timerElement.textContent = `남은 시간: ${remainingTime}s`;
            remainingTime--;
        } else {
            timerElement.textContent = '';
            clearInterval(timerInterval);

            if (skillType === 'disable_submit' && currentSkillPoints >= skillCost['disable_submit']) {
                skillIcon.classList.remove('disabled'); // Unlock skills after 'disable_submit' duration ends
            } else if (skillType === 'disable_typing' && currentSkillPoints >= skillCost['disable_typing']) {
                skillIcon.classList.remove('disabled');
            } else if (skillType === 'decay' && currentSkillPoints >= skillCost['decay']) {
                skillIcon.classList.remove('disabled');
            } else if (skillType === 'toxic_cloud' && currentSkillPoints >= skillCost['toxic_cloud']) {
                skillIcon.classList.remove('disabled');
            }

            if (skillType === 'disable_submit') {
                isSkillLocked = false; // Unlock skills after 'disable_submit' duration ends
            }
        }
    };

    updateTimer(); // Initialize timer display
    const timerInterval = setInterval(updateTimer, 1000); // Update every second
}

/*
function rechargeSkillPoints() {
const maxPoints = 7;
if (currentSkillPoints < maxPoints) {
    currentSkillPoints++;
    updateSkillPointsUI();
}
}

setInterval(rechargeSkillPoints, 5000);  
    */
socket.on('skill_effect', function(data) {
    if (data.skill === 'disable_typing' && data.status === 'active') {
        handleDisableTyping(); // 섬광탄 스킬 처리
    } else if (data.skill === 'disable_submit' && data.status === 'active') {
        handleDisableSubmit(); // 제출 금지 스킬 처리
    }
    if (data.skill === 'decay' && data.status === 'active') {
    startDecayEffect();
} else if (data.skill === 'decay' && data.status === 'inactive') {
    stopDecayEffect();
}
if (data.skill === 'toxic_cloud' && data.status === 'active') {
    activatetoxic_cloud(20);
} else if (data.skill === 'toxic_cloud' && data.status === 'inactive') {
    deactivatetoxic_cloud();
}
});

function handleDisableTyping() {
    const stunOverlay = document.getElementById('stunoverlay');
    const countdownTimer = document.getElementById('countdown-timer');

    // 기존의 타이머와 애니메이션을 초기화
    if (window.stunTimeout1) clearTimeout(window.stunTimeout1);
    if (window.stunTimeout2) clearTimeout(window.stunTimeout2);
    if (window.countdownInterval) clearInterval(window.countdownInterval);

    // 애니메이션을 다시 트리거하기 위해 애니메이션 초기화
    stunOverlay.style.animation = 'none'; // 애니메이션을 잠시 비활성화
    void stunOverlay.offsetWidth; // 트릭: 애니메이션을 재시작하기 위해 강제로 리플로우
    stunOverlay.style.animation = ''; // 애니메이션 다시 활성화

    // 초기 상태 설정
    stunOverlay.style.display = 'block';
    countdownTimer.style.display = 'block';

    let stunDuration = 5;
    countdownTimer.textContent = `Stun ends in: ${stunDuration}s`;

    // 새로운 카운트다운 타이머 설정
    window.countdownInterval = setInterval(() => {
        stunDuration--;
        if (stunDuration > 0) {
            countdownTimer.textContent = `Stun ends in: ${stunDuration}s`;
        } else {
            clearInterval(window.countdownInterval);
            stunOverlay.style.display = 'none';
            countdownTimer.style.display = 'none';
        }
    }, 1000);

    // 섬광탄 효과 (화면 왜곡 애니메이션)
    window.stunTimeout1 = setTimeout(() => {
        stunOverlay.style.animation = 'flashBangEffect 0.5s forwards, visionDistortion 3s forwards';
    }, 0); // 즉시 섬광 애니메이션 발생

    // 섬광탄 효과 종료 (화면 복구)
    window.stunTimeout2 = setTimeout(() => {
        stunOverlay.style.display = 'none';
    }, 8000);
}

function handleDisableSubmit() {
    const bodyElement = document.body;
    bodyElement.classList.add('glowing-inset-border');

    const submitButton = document.getElementById('submit-all');
    submitButton.disabled = true;
    submitButton.style.opacity = 0.5;

    const testButton = document.querySelector("button[onclick='runCode()']");
    testButton.disabled = true;
    testButton.style.opacity = 0.5;

    const skillIcons = document.querySelectorAll('.skill-icon');
    skillIcons.forEach(icon => {
        icon.classList.add('disabled');
    });

    let disableDuration = submitlockdowntime;
    setTimeout(() => {
        bodyElement.classList.remove('glowing-inset-border');
        submitButton.disabled = false;
        submitButton.style.opacity = 1;

        testButton.disabled = false;
        testButton.style.opacity = 1;
        skillIcons.forEach(icon => {
            icon.classList.remove('disabled');
        });
    }, disableDuration * 1000);
}

let activeDebuffs = {};

socket.on('skill_effect', function(data) {
    if (data.status === 'active') {
        const debuffName = data.skill;

        if (activeDebuffs[debuffName]) return;

        let debuffDuration;

        if (debuffName === 'disable_submit') {
            debuffDuration = submitlockdowntime;

        } else if (debuffName === 'disable_typing') {
            debuffDuration = 5;
        } else if (debuffName === 'decay') {
            debuffDuration = 0;
        } else if (debuffName === 'toxic_cloud') {
            debuffDuration = 20;
        }
        const debuffStartTime = new Date().getTime();
        const debuffEndTime = debuffStartTime + (debuffDuration * 1000);

        const debuffBox = document.createElement('div');
        debuffBox.classList.add('debuff-box');
        debuffBox.id = `debuff-${debuffName}`;

        debuffBox.innerHTML = `
            <div class="circle-container">
                <svg width="50" height="50">
                    <circle class="circle-background" cx="25" cy="25" r="20"></circle>
                    <circle class="circle-foreground" cx="25" cy="25" r="20" id="circle-${debuffName}"></circle>
                </svg>
            </div>
            <div class="debuff-timer">${debuffName.replace('_', ' ').toUpperCase()}</div>
        `;
        document.getElementById('debuff-container').appendChild(debuffBox);

        const initialDuration = debuffDuration * 1000;

        function updateCircle() {
            const circle = document.getElementById(`circle-${debuffName}`);
            const circumference = 2 * Math.PI * 20;
            const currentTime = new Date().getTime();
            const remainingTime = Math.max(debuffEndTime - currentTime, 0);
            const offset = circumference - (remainingTime / initialDuration) * circumference;
            circle.style.strokeDasharray = `${circumference} ${circumference}`;
            circle.style.strokeDashoffset = offset;

            if (remainingTime <= 0) {
                removeDebuff(debuffName);
            }
        }

        activeDebuffs[debuffName] = setInterval(updateCircle, 100);

        function removeDebuff(debuffName) {
            clearInterval(activeDebuffs[debuffName]);
            delete activeDebuffs[debuffName];

            const debuffBox = document.getElementById(`debuff-${debuffName}`);
            if (debuffBox) {
                debuffBox.classList.add('hidden');
                setTimeout(() => debuffBox.remove(), 1000);
            }
        }

        if (debuffName === 'disable_submit') {
            const bodyElement = document.body;
            bodyElement.classList.add('glowing-inset-border');

            const submitButton = document.getElementById('submit-all');
            const testButton = document.querySelector("button[onclick='runCode()']");
            submitButton.disabled = true;
            testButton.disabled = true;
            submitButton.style.opacity = 0.5;
            testButton.style.opacity = 0.5;

            setTimeout(() => {
                bodyElement.classList.remove('glowing-inset-border');
                submitButton.disabled = false;
                testButton.disabled = false;
                submitButton.style.opacity = 1;
                testButton.style.opacity = 1;
            }, debuffDuration * 1000);
        }
    }
});

function generateMathProblem() {
    const num1 = Math.floor(Math.random() * 1000) + 1;
    const num2 = Math.floor(Math.random() * 100) + 1;
    const operations = ['+', '-'];
    const operation = operations[Math.floor(Math.random() * operations.length)];

    const question = `${num1} ${operation} ${num2}`;
    const correctAnswer = eval(question); // 간단한 예제를 위해 eval 사용

    return {
        question,
        correctAnswer
    };
}

function showMathProblem() {
    resetTimer(); // 타이머 초기화
    currentMathProblem = generateMathProblem();
    document.getElementById('math-problem-question').innerText = `${currentMathProblem.question}`;
    document.getElementById('math-problem-modal').style.display = 'block';
    startCountdownTimer(); // 타이머 시작
}

function startCodeDeletion() {
    if (!isDeleting) {
        isDeleting = true; // 삭제 상태 활성화
        codeDeletionInterval = setInterval(() => {
            let code = editor.getValue();

            // 다양한 언어의 주석 제거
            let codeWithoutComments = code
                // 한 줄 주석 (C, C++, Java, JavaScript, Python에서 # 또는 // 로 시작하는 주석)
                .replace(/#.*|\/\/.*|\/\*[\s\S]*?\*\//g, '')
                // 여러 줄 주석 (C, C++, Java, JavaScript 등에서 /* */ 주석)
                .replace(/\/\*[\s\S]*?\*\//g, '')
                // Python의 ''' ''' 또는 """ """ 여러 줄 주석
                .replace(/('''[\s\S]*?'''|"""[\s\S]*?""")/g, '');

            // 공백 문자(탭, 개행, 스페이스) 제거
            let codeWithoutWhitespace = codeWithoutComments.replace(/\s+/g, '');

            if (codeWithoutWhitespace.length > 0) {
                // 삭제할 문자를 주석과 공백을 제외한 코드에서 선택
                const randomIndex = Math.floor(Math.random() * codeWithoutWhitespace.length);
                const charToDelete = codeWithoutWhitespace[randomIndex];

                // 원래 코드에서 해당 문자를 찾아 삭제
                let firstOccurrenceIndex = code.indexOf(charToDelete);
                if (firstOccurrenceIndex !== -1) {
                    code = code.slice(0, firstOccurrenceIndex) + code.slice(firstOccurrenceIndex + 1);
                    editor.setValue(code); // 에디터 내용 업데이트
                }

                editor.clearHistory(); // 삭제 후 undo 스택 비우기 (Ctrl+Z 복구 방지)
            } else {
                clearInterval(codeDeletionInterval); // 모든 코드가 삭제되면 타이머 종료
            }
        }, 1000); // 1초에 1글자 삭제
    }


}

function stopCodeDeletion() {
    clearInterval(codeDeletionInterval);
    isDeleting = false; // 삭제 상태 종료
}

let isMathProblemSolved = false; // 수학 문제 해결 여부를 추적하는 변수

function startDecayEffect() {
    const bodyElement = document.body;
    bodyElement.classList.add('glowing-inset-border-green');

    isMathProblemSolved = false; // 시작할 때는 문제 해결되지 않은 상태로 초기화
    if (!isDeleting) { // 삭제 중이 아니라면 문제 출제
        showMathProblem();
        startCodeDeletion();
    }

    decayInterval = setInterval(() => {
        if (!isMathProblemSolved && !isDeleting) { // 문제를 풀지 않았고 삭제 중이 아니라면 문제 출제
            showMathProblem();
        }
    }, 10000);
}

function stopDecayEffect() {
    const bodyElement = document.body;
    bodyElement.classList.remove('glowing-inset-border-green');

    clearInterval(decayInterval);
    stopCodeDeletion();
    stopCountdownTimer();
    document.getElementById('math-problem-modal').style.display = 'none';

    // decay 스킬 종료 후 아이콘 활성화
    const decaySkillIcon = document.getElementById('decay-icon');
    if (currentSkillPoints >= skillCost['decay']) {
        decaySkillIcon.classList.remove('disabled');
    }
}


function submitMathProblem() {
    const answer = parseFloat(document.getElementById('math-problem-answer').value);
    document.getElementById('math-problem-answer').value = ''; // 답안 초기화

    if (answer === currentMathProblem.correctAnswer) {
        isMathProblemSolved = true; // 문제를 해결했음을 표시
        document.getElementById('math-problem-modal').style.display = 'none';
        stopDecayEffect(); // 문제를 풀면 삭제 중단 및 Decay 종료
    } else {
        if (!isDeleting) { // 이미 삭제 중인 경우 중복으로 삭제가 시작되지 않도록 방지
            startCodeDeletion();
        }
        showMathProblem(); // 문제를 틀리면 새로운 문제 출제
    }
}



function startCountdownTimer() {
countdownStartTime = Date.now(); 
updateTimerDisplay(countdownDuration); 
clearInterval(countdownInterval); 

countdownInterval = setInterval(() => {
    const timeElapsed = Date.now() - countdownStartTime; 
    const timeRemaining = Math.max(0, countdownDuration - timeElapsed); 

    updateTimerDisplay(timeRemaining);

    if (timeRemaining === 0) {
        clearInterval(countdownInterval); 
        startCodeDeletion(); 
        showMathProblem(); 
    }
}, 100); 
}

function updateTimerDisplay(timeRemaining) {
const secondsRemaining = Math.floor(timeRemaining / 1000); 
document.getElementById('timer-display').innerText = `${secondsRemaining}`;
}

function stopCountdownTimer() {
clearInterval(countdownInterval); 
}

function resetTimer() {
countdownDuration = 10000; 
updateTimerDisplay(countdownDuration); 
}

socket.on('skill_effect', function(data) {
if (data.skill === 'decay' && data.status === 'active') {
    startDecayEffect();
} else if (data.skill === 'decay' && data.status === 'inactive') {
    stopDecayEffect();
}
if (data.skill === 'toxic_cloud' && data.status === 'active') {
    activatetoxic_cloud(20);
} else if (data.skill === 'toxic_cloud' && data.status === 'inactive') {
    deactivatetoxic_cloud();
}
});

let blurLevel = 0; 
const maxBlur = 20; 
let blurTimeout; 

function activatetoxic_cloud(duration) {
if (istoxic_cloudActive) return; 
istoxic_cloudActive = true;
console.log("toxic_cloud Activated");

const toxic_cloudOverlay = document.createElement('div');
toxic_cloudOverlay.classList.add('toxic_cloud-blur');
document.body.appendChild(toxic_cloudOverlay);

const blurDots = [];

for (let i = 0; i < 25; i++) {
    const blurDot = document.createElement('div');
    blurDot.classList.add('blur-dot');
    blurDot.style.top = `${Math.random() * 70}vh`;
    blurDot.style.left = `${Math.random() * 70}vw`;
    toxic_cloudOverlay.appendChild(blurDot);
    blurDots.push(blurDot); 

    blurDot.addEventListener('mouseenter', function() {
        handleMouseOver(blurDot); 
    });
}

setTimeout(deactivatetoxic_cloud, duration * 1000);
}

function handleMouseOver(blurDot) {
if (blurLevel < maxBlur) { 
    blurLevel += 2; 
    applyBlur(); 
    blurDot.style.animation = 'fastExpand 1s forwards'; 
}
}

function applyBlur() {
document.body.style.filter = `blur(${blurLevel}px)`; 

if (blurTimeout) clearTimeout(blurTimeout);
blurTimeout = setTimeout(removeBlur, 20000); 
}

function removeBlur() {
let currentBlur = blurLevel;

const interval = setInterval(() => {
    if (currentBlur > 0) {
        currentBlur -= 1; 
        document.body.style.filter = `blur(${currentBlur}px)`;
    } else {
        clearInterval(interval);
        blurLevel = 0; 
        document.body.style.filter = 'blur(0px)'; 
    }
}, 100); 
}

function deactivatetoxic_cloud() {
istoxic_cloudActive = false;
console.log("toxic_cloud Deactivated");

const toxic_cloudOverlay = document.querySelector('.toxic_cloud-blur');
if (toxic_cloudOverlay) {
    toxic_cloudOverlay.remove();
}

document.getElementById('toxic_cloud-icon').classList.remove('disabled');
}
    </script>

</body>
</html>
